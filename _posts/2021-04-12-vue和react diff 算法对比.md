---
layout: post
title: vue和react diff 算法对比
date: 2021-04-12
tags: "#vue2.0, #vue3.0, #react"
categories: ["Vue", "React"]
---

### react diff 算法

当调用 React 的 render()方法时，会创建一棵由 React 元素组成的树。在下一次 State 或 Props 更新时，相同的 render()方法会返回一棵不同的树。React 会应用 Diffing 算法来高效的比较两棵树，算法过程如下：

1. 当根节点为【不同类型】的元素时，React 会拆卸原有的树，销毁对应的 DOM 节点和关联的 State、卸载子组件，最后再创建新的树。
2. 当比对两个【相同类型的 DOM 元素】时，会保留 DOM 节点，【仅比对变更的属性】。
3. 当比对两个【相同类型的组件元素】时，组件实例保持不变，【更新该组件实例的 Props】。
4. 当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表，比对相同位置的元素，性能比较低效。
5. 在给子元素添加唯一标识的 key 属性后，就能只比对变更了 key 属性的元素。

### vue2.0 diff 算法

1. 先同级比较再比较子节点
2. 先判断一方有子节点和一方没有子节点的情况。如果新的一方有子节点，旧的一方没有，相当于新的子节点替代了原来没有的节点；同理，如果新的一方没有子节点，旧的一方有，相当于要把老的节点删除。
3. 再来比较都有子节点的情况，这里是 diff 的核心。首先会通过判断两个节点的 key、tag、isComment、data 同时定义或不定义以及当标签类型为 input 的时候 type 相不相同来确定两个节点是不是相同的节点，如果不是的话就将新节点替换旧节点。
4. 如果是相同节点的话才会进入到 patchVNode 阶段。在这个阶段核心是采用【双指针】的算法，同时从新旧节点的两端进行比较，在这个过程中，会用到模版编译时的静态标记配合 key 来跳过对比静态节点，如果不是的话再进行其它的比较。

- ** 缺点：因为采用的是同级比较，所以如果发现本级的节点不同的话就会将新节点直接替换旧节点，不会再去比较其下的子节点是否有相同 **

### vue2、vue3 和 react 比较

- vue2 和 vue3.x:
  Vue3.x 借鉴了 ivi 算法和 inferno 算法。
  它在创建 VNode 的时候就确定了其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。
- vue 和 react:
  共同点是：都是用同层比较，不同点是：vue 使用双指针比较，react 是用 key 集合级比较。
