<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2026-01-09T10:44:16+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jessie’s Blog</title><subtitle>A personal blog about technology, life and everything in between.</subtitle><author><name>Jessie Tang</name></author><entry><title type="html">Hello World - 我的第一篇博客文章</title><link href="http://localhost:4000/blog/2026/01/08/hello-world.html" rel="alternate" type="text/html" title="Hello World - 我的第一篇博客文章" /><published>2026-01-08T00:00:00+08:00</published><updated>2026-01-08T00:00:00+08:00</updated><id>http://localhost:4000/blog/2026/01/08/hello-world</id><content type="html" xml:base="http://localhost:4000/blog/2026/01/08/hello-world.html"><![CDATA[<h1 id="hello-world">Hello World</h1>

<p>这是我的第一篇博客文章！欢迎来到我的个人博客。</p>

<h2 id="为什么创建这个博客">为什么创建这个博客</h2>

<p>我创建这个博客的主要目的是：</p>

<ol>
  <li><strong>记录生活</strong>：记录生活中的点滴和思考</li>
  <li><strong>分享知识</strong>：分享我在技术学习和工作中的经验</li>
  <li><strong>交流成长</strong>：与更多志同道合的人交流，共同成长</li>
</ol>

<h2 id="博客的技术栈">博客的技术栈</h2>

<p>这个博客使用以下技术构建：</p>

<ul>
  <li><strong>Jekyll</strong>：静态网站生成器</li>
  <li><strong>GitHub Pages</strong>：网站部署平台</li>
  <li><strong>Markdown</strong>：文章编写格式</li>
  <li><strong>CSS</strong>：样式设计</li>
</ul>

<h2 id="如何编写博客文章">如何编写博客文章</h2>

<p>编写博客文章非常简单，只需要按照以下步骤：</p>

<ol>
  <li>在 <code class="language-plaintext highlighter-rouge">_posts</code> 目录下创建一个新的 Markdown 文件</li>
  <li>文件命名格式：<code class="language-plaintext highlighter-rouge">年-月-日-标题.md</code></li>
  <li>在文件顶部添加 YAML 前置元数据</li>
  <li>使用 Markdown 编写文章内容</li>
  <li>提交到 GitHub，自动部署</li>
</ol>

<h2 id="示例代码">示例代码</h2>

<p>以下是一个简单的 Python 代码示例：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Hello, World!</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># 这是一个注释
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">第 </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s"> 次输出</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="引用示例">引用示例</h2>

<blockquote>
  <p>技术的本质是服务于人，而不是相反。</p>
</blockquote>

<h2 id="下一步计划">下一步计划</h2>

<p>在未来的日子里，我计划：</p>

<ul>
  <li>分享更多技术文章</li>
  <li>记录学习过程</li>
  <li>分享生活感悟</li>
  <li>不断优化博客的功能和设计</li>
</ul>

<p>感谢您的访问！希望您能在这里找到有价值的内容。</p>

<!-- more -->

<p>这是文章的摘要分隔线，分隔线之前的内容会显示在首页的文章列表中，点击”阅读更多”后可以查看完整内容。</p>]]></content><author><name>Jessie Tang</name></author><category term="生活" /><category term="博客" /><summary type="html"><![CDATA[Hello World 这是我的第一篇博客文章！欢迎来到我的个人博客。 为什么创建这个博客 我创建这个博客的主要目的是： 记录生活：记录生活中的点滴和思考 分享知识：分享我在技术学习和工作中的经验 交流成长：与更多志同道合的人交流，共同成长 博客的技术栈 这个博客使用以下技术构建： Jekyll：静态网站生成器 GitHub Pages：网站部署平台 Markdown：文章编写格式 CSS：样式设计 如何编写博客文章 编写博客文章非常简单，只需要按照以下步骤： 在 _posts 目录下创建一个新的 Markdown 文件 文件命名格式：年-月-日-标题.md 在文件顶部添加 YAML 前置元数据 使用 Markdown 编写文章内容 提交到 GitHub，自动部署 示例代码 以下是一个简单的 Python 代码示例： print("Hello, World!") # 这是一个注释 for i in range(5): print(f"第 {i+1} 次输出") 引用示例 技术的本质是服务于人，而不是相反。 下一步计划 在未来的日子里，我计划： 分享更多技术文章 记录学习过程 分享生活感悟 不断优化博客的功能和设计 感谢您的访问！希望您能在这里找到有价值的内容。]]></summary></entry><entry><title type="html">测试</title><link href="http://localhost:4000/blog/2026/01/08/test.html" rel="alternate" type="text/html" title="测试" /><published>2026-01-08T00:00:00+08:00</published><updated>2026-01-08T00:00:00+08:00</updated><id>http://localhost:4000/blog/2026/01/08/test</id><content type="html" xml:base="http://localhost:4000/blog/2026/01/08/test.html"><![CDATA[<h1 id="hello-world">Hello World</h1>

<p>这是我的第一篇博客文章！欢迎来到我的个人博客。</p>

<h2 id="为什么创建这个博客">为什么创建这个博客</h2>

<p>我创建这个博客的主要目的是：</p>

<ol>
  <li><strong>记录生活</strong>：记录生活中的点滴和思考</li>
  <li><strong>分享知识</strong>：分享我在技术学习和工作中的经验</li>
  <li><strong>交流成长</strong>：与更多志同道合的人交流，共同成长</li>
</ol>]]></content><author><name>Jessie Tang</name></author><category term="前端" /><category term="博客" /><summary type="html"><![CDATA[Hello World 这是我的第一篇博客文章！欢迎来到我的个人博客。 为什么创建这个博客 我创建这个博客的主要目的是： 记录生活：记录生活中的点滴和思考 分享知识：分享我在技术学习和工作中的经验 交流成长：与更多志同道合的人交流，共同成长]]></summary></entry><entry><title type="html">js实现html转义及反转义</title><link href="http://localhost:4000/blog/2022/10/10/js%E5%AE%9E%E7%8E%B0html%E8%BD%AC%E4%B9%89%E5%8F%8A%E5%8F%8D%E8%BD%AC%E4%B9%89.html" rel="alternate" type="text/html" title="js实现html转义及反转义" /><published>2022-10-10T00:00:00+08:00</published><updated>2022-10-10T00:00:00+08:00</updated><id>http://localhost:4000/blog/2022/10/10/js%E5%AE%9E%E7%8E%B0html%E8%BD%AC%E4%B9%89%E5%8F%8A%E5%8F%8D%E8%BD%AC%E4%B9%89</id><content type="html" xml:base="http://localhost:4000/blog/2022/10/10/js%E5%AE%9E%E7%8E%B0html%E8%BD%AC%E4%B9%89%E5%8F%8A%E5%8F%8D%E8%BD%AC%E4%B9%89.html"><![CDATA[<h3 id="场景开发中我们常会在输入框输入东西然后提交然后会把提交的东西在某个地方进行渲染在输入框输入的时候我们可能会输入一些-html-标签或者特殊字符如等等这个时候我们通常会把它们进行转义后保存然后在获取渲染的时候进行反转义">场景：开发中，我们常会在输入框输入东西然后提交。然后，会把提交的东西在某个地方进行渲染。在输入框输入的时候，我们可能会输入一些 html 标签或者特殊字符，如&lt;、&gt;、@、”“等等。这个时候，我们通常会把它们进行转义后保存，然后在获取渲染的时候，进行反转义。</h3>

<p>例如：我们在输入框输入一段文本，</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'121'&lt;p&gt;123&lt;/p&gt;@"321"@
</code></pre></div></div>

<p>执行转义的方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function htmlEncode(html){
    const temp = document.createElement('div');
    temp.textContent !== null ? temp.textContent = html : temp.innerText = html;
    const output = temp.innerHTML;
    return output;
}
</code></pre></div></div>

<p>进行转义后，变成下面的字符串进行保存：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>htmlEncode(`'121'&lt;p&gt;123&lt;/p&gt;@"321"@`)
// 执行后输出：
'121'&amp;lt;p&amp;gt;123&amp;lt;/p&amp;gt;@"321"@
</code></pre></div></div>

<p>渲染的时候，进行反转义：
反转义方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function htmlDecode(text) {
    const temp = document.createElement('div');
    temp.innerHTML = text;
    const output = temp.innerText || temp.textContent;
    return output;
}
</code></pre></div></div>

<p>执行反转义后，变成下面的字符串：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>htmlDecode(`'121'&amp;lt;p&amp;gt;123&amp;lt;/p&amp;gt;@"321"@`)
// 执行后输出：
'121'&lt;p&gt;123&lt;/p&gt;@"321"@
</code></pre></div></div>

<p>另外，笔记：</p>

<p>innerHTML 指的是从对象的起始位置到终止位置的全部内容,包括 Html 标签。
innerText 指的是从起始位置到终止位置的内容,但它去除 Html 标签。</p>

<p>innerHTML 是所有浏览器都支持的
innerText 是 IE 浏览器和 chrome 浏览器支持的，Firefox 浏览器不支持。
Firefox 浏览器使用 textContent
其实，innerHTML 是 W3C 组织规定的属性；而 innerText 属性是 IE 浏览器自己的属性，不过后来的浏览器部分实现这个属性罢了。</p>]]></content><author><name>Jessie Tang</name></author><category term="vue" /><category term="#nuxt," /><category term="#vue" /><summary type="html"><![CDATA[场景：开发中，我们常会在输入框输入东西然后提交。然后，会把提交的东西在某个地方进行渲染。在输入框输入的时候，我们可能会输入一些 html 标签或者特殊字符，如&lt;、&gt;、@、”“等等。这个时候，我们通常会把它们进行转义后保存，然后在获取渲染的时候，进行反转义。 例如：我们在输入框输入一段文本， '121'&lt;p&gt;123&lt;/p&gt;@"321"@ 执行转义的方法： function htmlEncode(html){ const temp = document.createElement('div'); temp.textContent !== null ? temp.textContent = html : temp.innerText = html; const output = temp.innerHTML; return output; } 进行转义后，变成下面的字符串进行保存： htmlEncode(`'121'&lt;p&gt;123&lt;/p&gt;@"321"@`) // 执行后输出： '121'&amp;lt;p&amp;gt;123&amp;lt;/p&amp;gt;@"321"@ 渲染的时候，进行反转义： 反转义方法： function htmlDecode(text) { const temp = document.createElement('div'); temp.innerHTML = text; const output = temp.innerText || temp.textContent; return output; } 执行反转义后，变成下面的字符串： htmlDecode(`'121'&amp;lt;p&amp;gt;123&amp;lt;/p&amp;gt;@"321"@`) // 执行后输出： '121'&lt;p&gt;123&lt;/p&gt;@"321"@ 另外，笔记： innerHTML 指的是从对象的起始位置到终止位置的全部内容,包括 Html 标签。 innerText 指的是从起始位置到终止位置的内容,但它去除 Html 标签。 innerHTML 是所有浏览器都支持的 innerText 是 IE 浏览器和 chrome 浏览器支持的，Firefox 浏览器不支持。 Firefox 浏览器使用 textContent 其实，innerHTML 是 W3C 组织规定的属性；而 innerText 属性是 IE 浏览器自己的属性，不过后来的浏览器部分实现这个属性罢了。]]></summary></entry><entry><title type="html">遍历生成的el-select值的绑定，选中一个其他不变</title><link href="http://localhost:4000/blog/2022/09/02/%E9%81%8D%E5%8E%86%E7%94%9F%E6%88%90%E7%9A%84el-select%E5%80%BC%E7%9A%84%E7%BB%91%E5%AE%9A-%E9%80%89%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%B6%E4%BB%96%E4%B8%8D%E5%8F%98.html" rel="alternate" type="text/html" title="遍历生成的el-select值的绑定，选中一个其他不变" /><published>2022-09-02T00:00:00+08:00</published><updated>2022-09-02T00:00:00+08:00</updated><id>http://localhost:4000/blog/2022/09/02/%E9%81%8D%E5%8E%86%E7%94%9F%E6%88%90%E7%9A%84el-select%E5%80%BC%E7%9A%84%E7%BB%91%E5%AE%9A%EF%BC%8C%E9%80%89%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%B6%E4%BB%96%E4%B8%8D%E5%8F%98</id><content type="html" xml:base="http://localhost:4000/blog/2022/09/02/%E9%81%8D%E5%8E%86%E7%94%9F%E6%88%90%E7%9A%84el-select%E5%80%BC%E7%9A%84%E7%BB%91%E5%AE%9A-%E9%80%89%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%85%B6%E4%BB%96%E4%B8%8D%E5%8F%98.html"><![CDATA[<h4 id="问题在做项目的时候table数据是动态获取的table的某一列展示全是select下拉框table的另一列是根据当前行有select的那一列选择的数据来进行响应的操作这个时候每一个el-select组件绑定的值都是同一个改变某一行的select的数据其他行的都会跟着变因为绑定的是同一个值">问题：在做项目的时候，table数据是动态获取的，table的某一列展示全是select下拉框，table的另一列是根据当前行有select的那一列选择的数据，来进行响应的操作。这个时候，每一个el-select组件绑定的值都是同一个，改变某一行的select的数据，其他行的都会跟着变（因为绑定的是同一个值）。</h4>

<p>简单点描述就是：有一个数据列表，例如：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 源数据</span>
<span class="kd">var</span> <span class="nx">tableData</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">第一行数据</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">types</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">t1</span><span class="dl">'</span><span class="p">,</span>
                <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">aaa</span><span class="dl">'</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">t2</span><span class="dl">'</span><span class="p">,</span>
                <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bbb</span><span class="dl">'</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">t3</span><span class="dl">'</span><span class="p">,</span>
                <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ccc</span><span class="dl">'</span>
            <span class="p">}</span>
        <span class="p">]</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">id</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">第二行数据</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">types</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
                <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">t4</span><span class="dl">'</span><span class="p">,</span>
                <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ddd</span><span class="dl">'</span>
            <span class="p">},</span>
            <span class="p">{</span>
                <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">t5</span><span class="dl">'</span><span class="p">,</span>
                <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">eee</span><span class="dl">'</span>
            <span class="p">}</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">]</span>

<span class="c1">// 操作方法</span>
<span class="nf">handlePreview</span><span class="p">(</span><span class="nx">row</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">当前行选中的值为：</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">row</span><span class="p">.</span><span class="nx">selectedValue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>页面布局代码：</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;el-table</span>
      <span class="na">:data=</span><span class="s">"tableData"</span>
      <span class="na">style=</span><span class="s">"width: 100%"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;el-table-column</span>
        <span class="na">prop=</span><span class="s">"name"</span>
        <span class="na">label=</span><span class="s">"名字"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;/el-table-column&gt;</span>
      <span class="nt">&lt;el-table-column</span>
        <span class="na">prop=</span><span class="s">"types"</span>
        <span class="na">label=</span><span class="s">"类别"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;template</span> <span class="na">slot-scope=</span><span class="s">"scope"</span><span class="nt">&gt;</span>
            <span class="c">&lt;!-- 重点是这里怎么绑定v-model值 --&gt;</span>
            <span class="nt">&lt;el-select</span> <span class="na">v-model=</span><span class="s">"scope.row.selectedValue"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;el-option</span> 
                    <span class="na">v-for=</span><span class="s">"item in scope.row.types"</span> 
                    <span class="na">:key=</span><span class="s">"item.id"</span> 
                    <span class="na">:label=</span><span class="s">"item.name"</span> 
                    <span class="na">:value=</span><span class="s">"item.id"</span><span class="nt">&gt;</span>
                <span class="nt">&lt;/el-option&gt;</span>
            <span class="nt">&lt;/el-select&gt;</span>
        <span class="nt">&lt;/template&gt;</span>
      <span class="nt">&lt;/el-table-column&gt;</span>
      <span class="nt">&lt;el-table-column</span>
        <span class="na">prop=</span><span class="s">""</span>
        <span class="na">label=</span><span class="s">"操作"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;template</span> <span class="na">slot-scope=</span><span class="s">"scope"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;el-button</span> <span class="err">@</span><span class="na">click=</span><span class="s">"handlePreview(scope.row)"</span><span class="nt">&gt;</span>查看<span class="nt">&lt;/el-button&gt;</span>
        <span class="nt">&lt;/template&gt;</span>
      <span class="nt">&lt;/el-table-column&gt;</span>
    <span class="nt">&lt;/el-table&gt;</span>
  <span class="nt">&lt;/template&gt;</span>
</code></pre></div></div>

<p>解决思路： 只要让每一个选择器绑定的数据不一样就可以了，但拿到的tableData数组中的对象没有一个合适的属性去跟选择器绑定，那便新增一个属性好了。一开始，当前行数据scope.row里面没有selectedValue这个值，与其绑定的话，不会有值显示出来，后续点击选中某一项，scope.row就会新增selectedValue这个属性，属性值为选中的值，且其他行的选择器不受影响。</p>]]></content><author><name>Jessie Tang</name></author><category term="vue" /><category term="#vue," /><category term="#el-select" /><summary type="html"><![CDATA[问题：在做项目的时候，table数据是动态获取的，table的某一列展示全是select下拉框，table的另一列是根据当前行有select的那一列选择的数据，来进行响应的操作。这个时候，每一个el-select组件绑定的值都是同一个，改变某一行的select的数据，其他行的都会跟着变（因为绑定的是同一个值）。 简单点描述就是：有一个数据列表，例如： // 源数据 var tableData = [ { id: 1, name: '第一行数据', types: [ { id: 't1', name: 'aaa' }, { id: 't2', name: 'bbb' }, { id: 't3', name: 'ccc' } ] }, { id: 2, name: '第二行数据', types: [ { id: 't4', name: 'ddd' }, { id: 't5', name: 'eee' } ] } ] // 操作方法 handlePreview(row){ console.log('当前行选中的值为：' + row.selectedValue) } 页面布局代码： &lt;template&gt; &lt;el-table :data="tableData" style="width: 100%"&gt; &lt;el-table-column prop="name" label="名字"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="types" label="类别"&gt; &lt;template slot-scope="scope"&gt; &lt;!-- 重点是这里怎么绑定v-model值 --&gt; &lt;el-select v-model="scope.row.selectedValue"&gt; &lt;el-option v-for="item in scope.row.types" :key="item.id" :label="item.name" :value="item.id"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop="" label="操作"&gt; &lt;template slot-scope="scope"&gt; &lt;el-button @click="handlePreview(scope.row)"&gt;查看&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/template&gt; 解决思路： 只要让每一个选择器绑定的数据不一样就可以了，但拿到的tableData数组中的对象没有一个合适的属性去跟选择器绑定，那便新增一个属性好了。一开始，当前行数据scope.row里面没有selectedValue这个值，与其绑定的话，不会有值显示出来，后续点击选中某一项，scope.row就会新增selectedValue这个属性，属性值为选中的值，且其他行的选择器不受影响。]]></summary></entry><entry><title type="html">nuxt生产环境报错:Failed to execute ‘appendChild’ on ‘Node’</title><link href="http://localhost:4000/blog/2022/08/24/nuxt%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%88%B7%E6%96%B0%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html" rel="alternate" type="text/html" title="nuxt生产环境报错:Failed to execute ‘appendChild’ on ‘Node’" /><published>2022-08-24T00:00:00+08:00</published><updated>2022-08-24T00:00:00+08:00</updated><id>http://localhost:4000/blog/2022/08/24/nuxt%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%88%B7%E6%96%B0%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3</id><content type="html" xml:base="http://localhost:4000/blog/2022/08/24/nuxt%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%88%B7%E6%96%B0%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3.html"><![CDATA[<h3 id="问题nuxt生产环境报错failed-to-execute-appendchild-on-node-this-node-type-does-not-support-this-method">问题：nuxt生产环境报错:Failed to execute ‘appendChild’ on ‘Node’— This node type does not support this method…</h3>

<p>使用nuxt的时候，本地运行没问题，部署到生产环境之后，初次加载没问题，刷新页面，就报错：Failed to execute ‘appendChild’ on ‘Node’: This node type does not support this method…</p>

<p>类似的问题，还在另一个项目遇到过，修改地址栏，页面导航到404路由页面，也是报同样的错。开始以为是nginx配置有问题，结果对比另一个项目的配置，发现并没有任何不一样的地方。</p>

<p>搁置了一段时间这个问题，然后在遇到某个页面刷新报错的时候，联想到应该是同一类问题。</p>

<p>查阅资料，有好几种出现该问题的原因。</p>

<p>其中一个最能让我觉得靠谱的就是，”出错的部分是在layouts模板文件中引入的，而不是动态渲染nuxt部分，所以可以猜测应该是模板中的除了动态渲染的部分以外，其余都得用v-show所控制的css样式去让它显示隐藏，而不能用v-if，应该是模板内不支持动态生成元素方法，就如报错的appendChild”。</p>

<p>解决办法是，根据使用的nuxt版本，在该组件的外层加一个<client-only>或者<no-ssr>即可解决。
If you are using a version of Nuxt &lt; v2.9.0, use <no-ssr> instead of <client-only></client-only></no-ssr></no-ssr></client-only></p>
<client-only>需要安装第三方组件：vue-client-only后使用。

实践证明，确实如此。
</client-only>]]></content><author><name>Jessie Tang</name></author><category term="vue" /><category term="#nuxt," /><category term="#vue" /><summary type="html"><![CDATA[问题：nuxt生产环境报错:Failed to execute ‘appendChild’ on ‘Node’— This node type does not support this method… 使用nuxt的时候，本地运行没问题，部署到生产环境之后，初次加载没问题，刷新页面，就报错：Failed to execute ‘appendChild’ on ‘Node’: This node type does not support this method… 类似的问题，还在另一个项目遇到过，修改地址栏，页面导航到404路由页面，也是报同样的错。开始以为是nginx配置有问题，结果对比另一个项目的配置，发现并没有任何不一样的地方。 搁置了一段时间这个问题，然后在遇到某个页面刷新报错的时候，联想到应该是同一类问题。 查阅资料，有好几种出现该问题的原因。 其中一个最能让我觉得靠谱的就是，”出错的部分是在layouts模板文件中引入的，而不是动态渲染nuxt部分，所以可以猜测应该是模板中的除了动态渲染的部分以外，其余都得用v-show所控制的css样式去让它显示隐藏，而不能用v-if，应该是模板内不支持动态生成元素方法，就如报错的appendChild”。 解决办法是，根据使用的nuxt版本，在该组件的外层加一个或者即可解决。 If you are using a version of Nuxt &lt; v2.9.0, use instead of 需要安装第三方组件：vue-client-only后使用。 实践证明，确实如此。]]></summary></entry><entry><title type="html">2022年3、4月找工作面试题合集整理</title><link href="http://localhost:4000/blog/2022/04/30/3-4%E6%9C%88%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86.html" rel="alternate" type="text/html" title="2022年3、4月找工作面试题合集整理" /><published>2022-04-30T00:00:00+08:00</published><updated>2022-04-30T00:00:00+08:00</updated><id>http://localhost:4000/blog/2022/04/30/3%E3%80%814%E6%9C%88%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86</id><content type="html" xml:base="http://localhost:4000/blog/2022/04/30/3-4%E6%9C%88%E6%89%BE%E5%B7%A5%E4%BD%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86%E6%95%B4%E7%90%86.html"><![CDATA[<h4 id="最近34月份大概面了10家的公司每次面试下来我都会简单的整理记录一下面试官闻到的问题也有一些自己可能当时没领会到后面突然某一天醒悟的一些问题按类别分类整理如下">最近3、4月份，大概面了10+家的公司，每次面试下来，我都会简单的整理记录一下，面试官闻到的问题。也有一些自己可能当时没领会到，后面突然某一天醒悟的一些问题。按类别分类整理如下：</h4>

<h4 id="一前端基础知识">一、前端基础知识</h4>

<ol>
  <li>什么是跨域？</li>
  <li>什么是函数节流和防抖？</li>
  <li>前端性能优化可以从哪些方面做？你做过哪些？</li>
  <li>对称加密和非对称加密，是什么，各自有什么优缺点？</li>
  <li>排序算法实现：快速排序、冒泡排序、选择排序。数组sort排序用的什么排序？</li>
  <li>http三次握手？</li>
  <li>websocket怎么发数据</li>
  <li>https加密过程</li>
  <li>地址栏输入网址，回车，做了什么？</li>
  <li>react vue区别</li>
  <li>常见的web漏洞介绍及解决方案？(XSS、CSRF）</li>
  <li>webpack配置组件按需加载怎么做？</li>
  <li>虚拟dom有什么好处？</li>
  <li>跨域解决方案？跨域了请求到底发到后端去没有？浏览器同源策略 拦截 是在什么时候拦截的？</li>
  <li>移动端适配 怎么做？ rem html根部设置那个值根据什么来计算应该设置多少？</li>
  <li>js数据类型有哪些？判断数据类型有哪些方法？</li>
  <li>深克隆有哪些方法？</li>
  <li>http1和http2的区别</li>
  <li>typeof null 是啥？为啥是object ？</li>
  <li>你做过的性能优化，举例说明</li>
  <li>简单介绍一下你了解的rn</li>
  <li>前端代码审查主要做些啥？</li>
  <li>函数柯里化是什么？</li>
  <li>箭头函数中的this和普通函数中的this指向？</li>
  <li>Promise有哪些方法？promise.all和promise.allSettled区别？自己实现一个promise.all、promise.race、promise.allSettled方法</li>
  <li>如何在事件代理中正确使用 focus 和 blur 事件?</li>
  <li>遇到过印象深刻的问题，以及如何解决的</li>
  <li>怎么样去取消一个ajax api请求？</li>
  <li>纯函数是什么？</li>
  <li>开闭原则是什么?</li>
  <li>代码设计，六大设计原则</li>
  <li>websocket是怎么保持长链接的？ socket之tcp如何维护长连接？</li>
  <li>RN本质?</li>
  <li>RN是如何做到JS和OC交互的？</li>
  <li>解释一下null == undefined 为啥是true？</li>
  <li>数组的reduce方法</li>
  <li>去掉一个字符串前后空格有哪些实现方式？</li>
  <li>es6新特性常见的有哪些</li>
  <li>for循环里面用let和var有啥不同？</li>
  <li>http缓存(浏览器缓存），from disk, from memory原理？</li>
  <li>data数据具有父子关系的这种，变成tree形数据，怎么操作？</li>
  <li>监听订阅者模式，怎么实现？</li>
  <li>常见的哪些性能优化？webpack gulp都怎么样使用过？</li>
  <li>跨域处理方式?</li>
  <li>nginx配置？页面跳转没问题，刷新就报错了</li>
  <li>emit/on/onOnce/off 实现</li>
  <li>http和tcp关系和区别 udp</li>
  <li>http包的格式</li>
  <li>::after</li>
  <li>box-sizing: content-box/border-box</li>
  <li>flex 父容器有哪些属性，子容器可以有哪些属性</li>
  <li>reduce实现</li>
  <li>Funtion.prototype.bind方法实现</li>
  <li>多人协助冲突问题解决方案？</li>
  <li>时间复杂度、空间复杂度？</li>
  <li>call apply bind区别</li>
  <li>数组截取部分元素的方法</li>
  <li>this指向问题</li>
  <li>代码执行顺序问题（js单线程和任务队列、宏任务、微任务）</li>
  <li>ul下面有四个li,  删除第三个li元素</li>
  <li>正则</li>
  <li>css实现九宫格布局 左右两边抵拢</li>
  <li>css实现多主题切换，怎么设计</li>
  <li>移动端实现1px方案</li>
  <li>typescript 里面 any和unknown区别</li>
  <li>typescript里面 两个问号和两个竖线区别？</li>
  <li>CSRF 跨站请求伪造是什么？</li>
  <li>跨域及解决方案？options请求是什么？</li>
  <li>网页从输入地址栏到加载出来，这中间经历了什么？</li>
  <li>js单线程和事件循环？宏任务和微任务？</li>
  <li>http缓存机制（强制缓存+协商缓存）</li>
  <li>webpack有哪几个模块 分别是干啥的？</li>
  <li>setTimeout(fn, 3000) 一定是3s之后执行？</li>
  <li>vue 和 react的diff区别</li>
  <li>position有哪些值</li>
  <li>左边100 右边200 中间自适应 怎么布局</li>
  <li>git pull 和 git fetch区别？</li>
  <li>需求评审到最终上线中间要经历哪些过程？会输出一些什么东西？有哪些风险控制？</li>
  <li>transition动画什么时候停止？</li>
  <li>document.getElementsByTagName(‘div’) 返回的数据类型是什么类型？</li>
  <li>document.querySelectorAll(‘div’)返回的数据类型是什么类型？</li>
  <li>前端单元测试怎么做？</li>
  <li>http状态码 200 301 304 404 401 403</li>
  <li>webpack hash contenthash chunkhash区别</li>
  <li>display:none  visibility:hidden opacity:0 区别</li>
  <li>说一个最近做的组件封装</li>
  <li>promise.all  &amp;  promise.race区别</li>
  <li>写算法，rgb转十六进制</li>
  <li>promise.then怎么实现</li>
  <li>闭包
<br /></li>
</ol>

<h4 id="二前端框架-react">二、前端框架-react</h4>
<ol>
  <li>React 分包怎么做？</li>
  <li>合成事件是什么? 跟原生事件区别?</li>
  <li>合成事件 是挂载到哪里的?</li>
  <li>合成事件中的冒泡 是怎么样的 是真实的冒泡吗？</li>
  <li>useState或者说setState是异步的还是同步的？</li>
  <li>介绍一下react里面的fiber是什么？</li>
  <li>redux讲述一下?</li>
  <li>useCallback  useMemo区别？useEffect可以拿来做什么？</li>
  <li>有自己写过hook么？怎么写？</li>
  <li>react事件池介绍一下？</li>
  <li>react-redux中的高阶函数connect介绍一下</li>
  <li>高阶组件是什么</li>
  <li>用过哪些hook。讲一下useEffect的参数</li>
  <li>if else 里面可以用hook么？ 为什么？ hook使用规则是什么？</li>
  <li>context 怎么用 有哪些方法？</li>
  <li>react有哪些hook</li>
  <li>useReducer是用来干啥的？</li>
  <li>react里面可以用来通信，组件间传值的是哪个hooks？怎么用？</li>
  <li>父组件子组件通信怎么做？</li>
  <li>用过哪些 redux 中间件？</li>
  <li>redux-saga用过没有？</li>
  <li>immer的使用（主要是produce方法）</li>
  <li>react里面的useState原理？</li>
  <li>useEffect第二个参数不传代表什么？useEffect第一个参数直接return代表什么？第二个参数，是可选参数，不传参数或者穿数组（空数组、一个值的数组、多个值的数组）</li>
  <li>react生命周期</li>
  <li>react hooks为什么只能用在顶层？</li>
  <li>useRef用来做变量保存？</li>
  <li>react-router 几种模式阐述一下？为什么路由切换，页面不会闪烁？</li>
  <li>react diff算法研究过吗？</li>
  <li>useEffect介绍一下 ？hook介绍一下？</li>
  <li>react使用什么做数据状态管理</li>
  <li>react里面setState合并状态更新操作</li>
  <li>react合成事件冒泡</li>
  <li>react生命周期 在函数组件和class类组件中分别是什么？</li>
  <li>react class组件和函数组件区别？</li>
  <li>react组件优化主要从哪些地方入手做的？
<br /></li>
</ol>

<h4 id="三前端框架-vue">三、前端框架-vue</h4>
<ol>
  <li>vue双向绑定原理？</li>
  <li>vue keep-alive用来干啥？</li>
  <li>vue页面切换数据上个页面数据不丢失怎么做？（keep-alive）</li>
  <li>vuex讲述一下?</li>
  <li>vue中使用v-bind=”$attrs”和v-on=”$listeners”进行多层组件监听</li>
  <li>做过的vue组件优化问题</li>
  <li>双向数据绑定核心原理？</li>
  <li>vue单文件为啥样式加了scope 就可以隔离样式？</li>
  <li>vue $nextTick原理？</li>
  <li>vue mixins</li>
  <li>vue生命周期</li>
  <li>vue 自定义指令 directive</li>
  <li>v-model原理</li>
  <li>vue自定义指令、过滤器</li>
  <li>vuex介绍一下，数据怎么流动的</li>
  <li>vue绑定class和style写法</li>
</ol>]]></content><author><name>Jessie Tang</name></author><category term="面试合集" /><category term="#面试" /><summary type="html"><![CDATA[最近3、4月份，大概面了10+家的公司，每次面试下来，我都会简单的整理记录一下，面试官闻到的问题。也有一些自己可能当时没领会到，后面突然某一天醒悟的一些问题。按类别分类整理如下： 一、前端基础知识 什么是跨域？ 什么是函数节流和防抖？ 前端性能优化可以从哪些方面做？你做过哪些？ 对称加密和非对称加密，是什么，各自有什么优缺点？ 排序算法实现：快速排序、冒泡排序、选择排序。数组sort排序用的什么排序？ http三次握手？ websocket怎么发数据 https加密过程 地址栏输入网址，回车，做了什么？ react vue区别 常见的web漏洞介绍及解决方案？(XSS、CSRF） webpack配置组件按需加载怎么做？ 虚拟dom有什么好处？ 跨域解决方案？跨域了请求到底发到后端去没有？浏览器同源策略 拦截 是在什么时候拦截的？ 移动端适配 怎么做？ rem html根部设置那个值根据什么来计算应该设置多少？ js数据类型有哪些？判断数据类型有哪些方法？ 深克隆有哪些方法？ http1和http2的区别 typeof null 是啥？为啥是object ？ 你做过的性能优化，举例说明 简单介绍一下你了解的rn 前端代码审查主要做些啥？ 函数柯里化是什么？ 箭头函数中的this和普通函数中的this指向？ Promise有哪些方法？promise.all和promise.allSettled区别？自己实现一个promise.all、promise.race、promise.allSettled方法 如何在事件代理中正确使用 focus 和 blur 事件? 遇到过印象深刻的问题，以及如何解决的 怎么样去取消一个ajax api请求？ 纯函数是什么？ 开闭原则是什么? 代码设计，六大设计原则 websocket是怎么保持长链接的？ socket之tcp如何维护长连接？ RN本质? RN是如何做到JS和OC交互的？ 解释一下null == undefined 为啥是true？ 数组的reduce方法 去掉一个字符串前后空格有哪些实现方式？ es6新特性常见的有哪些 for循环里面用let和var有啥不同？ http缓存(浏览器缓存），from disk, from memory原理？ data数据具有父子关系的这种，变成tree形数据，怎么操作？ 监听订阅者模式，怎么实现？ 常见的哪些性能优化？webpack gulp都怎么样使用过？ 跨域处理方式? nginx配置？页面跳转没问题，刷新就报错了 emit/on/onOnce/off 实现 http和tcp关系和区别 udp http包的格式 ::after box-sizing: content-box/border-box flex 父容器有哪些属性，子容器可以有哪些属性 reduce实现 Funtion.prototype.bind方法实现 多人协助冲突问题解决方案？ 时间复杂度、空间复杂度？ call apply bind区别 数组截取部分元素的方法 this指向问题 代码执行顺序问题（js单线程和任务队列、宏任务、微任务） ul下面有四个li, 删除第三个li元素 正则 css实现九宫格布局 左右两边抵拢 css实现多主题切换，怎么设计 移动端实现1px方案 typescript 里面 any和unknown区别 typescript里面 两个问号和两个竖线区别？ CSRF 跨站请求伪造是什么？ 跨域及解决方案？options请求是什么？ 网页从输入地址栏到加载出来，这中间经历了什么？ js单线程和事件循环？宏任务和微任务？ http缓存机制（强制缓存+协商缓存） webpack有哪几个模块 分别是干啥的？ setTimeout(fn, 3000) 一定是3s之后执行？ vue 和 react的diff区别 position有哪些值 左边100 右边200 中间自适应 怎么布局 git pull 和 git fetch区别？ 需求评审到最终上线中间要经历哪些过程？会输出一些什么东西？有哪些风险控制？ transition动画什么时候停止？ document.getElementsByTagName(‘div’) 返回的数据类型是什么类型？ document.querySelectorAll(‘div’)返回的数据类型是什么类型？ 前端单元测试怎么做？ http状态码 200 301 304 404 401 403 webpack hash contenthash chunkhash区别 display:none visibility:hidden opacity:0 区别 说一个最近做的组件封装 promise.all &amp; promise.race区别 写算法，rgb转十六进制 promise.then怎么实现 闭包 二、前端框架-react React 分包怎么做？ 合成事件是什么? 跟原生事件区别? 合成事件 是挂载到哪里的? 合成事件中的冒泡 是怎么样的 是真实的冒泡吗？ useState或者说setState是异步的还是同步的？ 介绍一下react里面的fiber是什么？ redux讲述一下? useCallback useMemo区别？useEffect可以拿来做什么？ 有自己写过hook么？怎么写？ react事件池介绍一下？ react-redux中的高阶函数connect介绍一下 高阶组件是什么 用过哪些hook。讲一下useEffect的参数 if else 里面可以用hook么？ 为什么？ hook使用规则是什么？ context 怎么用 有哪些方法？ react有哪些hook useReducer是用来干啥的？ react里面可以用来通信，组件间传值的是哪个hooks？怎么用？ 父组件子组件通信怎么做？ 用过哪些 redux 中间件？ redux-saga用过没有？ immer的使用（主要是produce方法） react里面的useState原理？ useEffect第二个参数不传代表什么？useEffect第一个参数直接return代表什么？第二个参数，是可选参数，不传参数或者穿数组（空数组、一个值的数组、多个值的数组） react生命周期 react hooks为什么只能用在顶层？ useRef用来做变量保存？ react-router 几种模式阐述一下？为什么路由切换，页面不会闪烁？ react diff算法研究过吗？ useEffect介绍一下 ？hook介绍一下？ react使用什么做数据状态管理 react里面setState合并状态更新操作 react合成事件冒泡 react生命周期 在函数组件和class类组件中分别是什么？ react class组件和函数组件区别？ react组件优化主要从哪些地方入手做的？ 三、前端框架-vue vue双向绑定原理？ vue keep-alive用来干啥？ vue页面切换数据上个页面数据不丢失怎么做？（keep-alive） vuex讲述一下? vue中使用v-bind=”$attrs”和v-on=”$listeners”进行多层组件监听 做过的vue组件优化问题 双向数据绑定核心原理？ vue单文件为啥样式加了scope 就可以隔离样式？ vue $nextTick原理？ vue mixins vue生命周期 vue 自定义指令 directive v-model原理 vue自定义指令、过滤器 vuex介绍一下，数据怎么流动的 vue绑定class和style写法]]></summary></entry><entry><title type="html">实现一个简单的监听订阅者模式</title><link href="http://localhost:4000/blog/2022/04/30/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%91%E5%90%AC%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F.html" rel="alternate" type="text/html" title="实现一个简单的监听订阅者模式" /><published>2022-04-30T00:00:00+08:00</published><updated>2022-04-30T00:00:00+08:00</updated><id>http://localhost:4000/blog/2022/04/30/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%91%E5%90%AC%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/blog/2022/04/30/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%9B%91%E5%90%AC%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F.html"><![CDATA[<h4 id="实现该模式需要提前搞清楚的点">实现该模式需要提前搞清楚的点：</h4>
<ol>
  <li>监听订阅者模式是什么？</li>
  <li>如果要自己实现，应该怎么样去实现？</li>
  <li>一个事件可以注册多个不同的处理事件函数，应该怎么存放数据？</li>
  <li>一个事件有多个处理函数，怎么进行选择性取消？（注册的时候，返回一个取消注册，每次注册的时候，把需要选择取消的返回函数收集起来统一执行就可以进行取消）</li>
</ol>

<p>直接上代码啊：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nf">EasyEventEmitter</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">notifys</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="c1">// 满足正则匹配 * </span>
  <span class="kd">let</span> <span class="nx">notifyAnys</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kd">let</span> <span class="nx">timeout</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="kd">const</span> <span class="nx">del</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cacheNotify</span> <span class="o">=</span> <span class="nf">getCacheByKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">delete</span> <span class="nx">cacheNotify</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="c1">// 没有指定fun，则删除全部</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">ls</span> <span class="o">=</span> <span class="nx">cacheNotify</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">ls</span> <span class="o">&amp;&amp;</span> <span class="nx">ls</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">a</span> <span class="o">&lt;</span> <span class="nx">ls</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">ls</span><span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="o">===</span> <span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">ls</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
          <span class="k">break</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nf">getCacheByKey</span><span class="p">(</span><span class="nx">key</span><span class="p">){</span>
    <span class="k">return</span> <span class="sr">/</span><span class="se">\*</span><span class="sr">/</span><span class="p">.</span><span class="nf">test</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">?</span> <span class="nx">notifyAnys</span> <span class="p">:</span> <span class="nx">notifys</span>
  <span class="p">}</span>

  <span class="c1">// on的时候，进行注册，每注册一个，生成对象的一个key/value, value是数组，如果key相同，则value数组进行push handler。</span>
  <span class="c1">// on函数返回当前注册这个事件名称的取消注册函数。</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">on</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fun</span><span class="p">,</span> <span class="nx">isOnly</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">cacheNotify</span> <span class="o">=</span> <span class="nf">getCacheByKey</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
  
    <span class="nx">cacheNotify</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">cacheNotify</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">||</span> <span class="p">[]</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">isOnly</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">cacheNotify</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="p">}</span>
    <span class="nx">cacheNotify</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nf">push</span><span class="p">(</span><span class="nx">fun</span><span class="p">)</span>

    <span class="c1">// 返回取消注册函数</span>
    <span class="k">return </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="nf">del</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fun</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// onOnce内部执行on这个方法，并且接受返回值unOff方法，然后执行调用onOff.</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">onOnce</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fun</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">unOff</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nf">fun</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span>
      <span class="nf">unOff</span><span class="p">()</span>
    <span class="p">})</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">emit</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">ls</span> <span class="o">=</span> <span class="nx">notifys</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>

    <span class="c1">// * </span>
    <span class="kd">let</span> <span class="nx">anys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nf">keys</span><span class="p">(</span><span class="nx">notifyAnys</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">anys</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
      <span class="kd">let</span> <span class="nx">newLs</span><span class="o">=</span> <span class="p">[]</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">of</span> <span class="nx">anys</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="k">new</span> <span class="nc">RegExp</span><span class="p">(</span><span class="nx">i</span><span class="p">).</span><span class="nf">test</span><span class="p">(</span><span class="nx">key</span><span class="p">)){</span>
          <span class="nx">newLs</span><span class="p">.</span><span class="nf">push</span><span class="p">(...</span><span class="nx">notifyAnys</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">newLs</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">ls</span><span class="p">){</span>
          <span class="nx">newLs</span><span class="p">.</span><span class="nf">splice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,...</span><span class="nx">ls</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">ls</span> <span class="o">=</span> <span class="nx">newLs</span>
      <span class="p">}</span>
    <span class="p">}</span>
   
    <span class="k">if </span><span class="p">(</span><span class="nx">ls</span> <span class="o">&amp;&amp;</span> <span class="nx">ls</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="nx">ls</span><span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nx">handler</span> <span class="o">=&gt;</span> <span class="nx">handler</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">))</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">off</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fun</span><span class="p">)</span> <span class="p">{</span> <span class="nf">del</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">fun</span><span class="p">)</span> <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">emitDelay</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">delay</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">timeout</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span> <span class="p">{</span>
      <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">timeout</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">args</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">timeout</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nf">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nf">emit</span><span class="p">(</span><span class="nx">key</span><span class="p">,...</span><span class="nx">args</span><span class="p">)</span>
    <span class="p">},</span> <span class="nx">delay</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">isOn</span> <span class="o">=</span> <span class="nx">key</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!!</span><span class="nx">notifys</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="k">this</span><span class="p">.</span><span class="nx">clearNotify</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">notifys</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="nx">notifyAnys</span><span class="o">=</span> <span class="p">{}</span>
    <span class="k">for </span><span class="p">(</span><span class="kd">const</span> <span class="nx">k</span> <span class="k">in</span> <span class="nx">timeout</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">clearTimeout</span><span class="p">(</span><span class="nx">timeout</span><span class="p">[</span><span class="nx">k</span><span class="p">])</span>
    <span class="p">}</span>
    <span class="nx">timeout</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>]]></content><author><name>Jessie Tang</name></author><category term="面试合集" /><category term="零散的知识点积累" /><category term="#监听订阅者模式" /><summary type="html"><![CDATA[实现该模式需要提前搞清楚的点： 监听订阅者模式是什么？ 如果要自己实现，应该怎么样去实现？ 一个事件可以注册多个不同的处理事件函数，应该怎么存放数据？ 一个事件有多个处理函数，怎么进行选择性取消？（注册的时候，返回一个取消注册，每次注册的时候，把需要选择取消的返回函数收集起来统一执行就可以进行取消） 直接上代码啊： export function EasyEventEmitter () { let notifys = {} // 满足正则匹配 * let notifyAnys = {} let timeout = {} const del = function (key, fun) { let cacheNotify = getCacheByKey(key) if (!fun) { delete cacheNotify[key] // 没有指定fun，则删除全部 } const ls = cacheNotify[key] if (ls &amp;&amp; ls.length) { for (let a = 0; a &lt; ls.length; a++) { if (ls[a] === fun) { ls.splice(a, 1) break } } } } function getCacheByKey(key){ return /\*/.test(key) ? notifyAnys : notifys } // on的时候，进行注册，每注册一个，生成对象的一个key/value, value是数组，如果key相同，则value数组进行push handler。 // on函数返回当前注册这个事件名称的取消注册函数。 this.on = function (key, fun, isOnly) { let cacheNotify = getCacheByKey(key) cacheNotify[key] = cacheNotify[key] || [] if (isOnly) { cacheNotify[key].length = 0 } cacheNotify[key].push(fun) // 返回取消注册函数 return () =&gt; del(key, fun) } // onOnce内部执行on这个方法，并且接受返回值unOff方法，然后执行调用onOff. this.onOnce = function(key, fun) { const unOff = this.on(key, (...args) =&gt; { fun(...args) unOff() }) } this.emit = function (key) { let ls = notifys[key] // * let anys = Object.keys(notifyAnys) if(anys.length){ let newLs= [] for(let i of anys){ if(new RegExp(i).test(key)){ newLs.push(...notifyAnys[i]) } } if(newLs.length){ if(ls){ newLs.splice(0,0,...ls) } ls = newLs } } if (ls &amp;&amp; ls.length) { const args = Array.prototype.slice.call(arguments, 1) ls.forEach(handler =&gt; handler.apply(this, args)) } } this.off = function(key, fun) { del(key, fun) } this.emitDelay = function (key, delay) { if (timeout[key]) { clearTimeout(timeout[key]) } let args = Array.prototype.slice.call(arguments, 2) timeout[key] = setTimeout(() =&gt; { this.emit(key,...args) }, delay) } this.isOn = key =&gt; { return !!notifys[key] } this.clearNotify = function() { notifys = {} notifyAnys= {} for (const k in timeout) { clearTimeout(timeout[k]) } timeout = {} } }]]></summary></entry><entry><title type="html">具有父子关系的list数据转变成tree形数据实现</title><link href="http://localhost:4000/blog/2022/04/30/%E5%85%B7%E6%9C%89%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E7%9A%84list%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%98%E6%88%90tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0.html" rel="alternate" type="text/html" title="具有父子关系的list数据转变成tree形数据实现" /><published>2022-04-30T00:00:00+08:00</published><updated>2022-04-30T00:00:00+08:00</updated><id>http://localhost:4000/blog/2022/04/30/%E5%85%B7%E6%9C%89%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E7%9A%84list%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%98%E6%88%90tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0</id><content type="html" xml:base="http://localhost:4000/blog/2022/04/30/%E5%85%B7%E6%9C%89%E7%88%B6%E5%AD%90%E5%85%B3%E7%B3%BB%E7%9A%84list%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%98%E6%88%90tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E5%AE%9E%E7%8E%B0.html"><![CDATA[<h4 id="我们在实际开发需求的过程中经常会遇到需要把list形式的数据转成tree形的数据的场景那么是否可以写一个通用的方法来处理这种情形呢">我们在实际开发需求的过程中，经常会遇到需要把list形式的数据，转成tree形的数据的场景。那么，是否可以写一个通用的方法来处理这种情形呢？</h4>

<p>直接上代码：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getTreeFromRows</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">rows</span><span class="p">,</span>
  <span class="nx">rootId</span><span class="p">,</span>
  <span class="nx">idKey</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">parentKey</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">parent</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">labelKey</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">name</span><span class="dl">'</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nf">getNodes</span><span class="p">(</span><span class="nx">rows</span><span class="p">,</span> <span class="nx">rootId</span><span class="p">,</span> <span class="nx">currentNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">rows</span>
      <span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">[</span><span class="nx">parentKey</span><span class="p">]</span> <span class="o">==</span> <span class="nx">rootId</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">forEach</span><span class="p">(</span><span class="nx">row</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">children</span> <span class="o">=</span> <span class="nf">getNodes</span><span class="p">(</span><span class="nx">rows</span><span class="p">,</span> <span class="nx">row</span><span class="p">[</span><span class="nx">idKey</span><span class="p">],</span> <span class="p">[])</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">children</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="nx">children</span> <span class="o">=</span> <span class="kc">null</span>
        <span class="nx">currentNodes</span><span class="p">.</span><span class="nf">push</span><span class="p">({</span>
          <span class="p">...</span><span class="nx">row</span><span class="p">,</span>
          <span class="na">id</span><span class="p">:</span> <span class="nx">row</span><span class="p">[</span><span class="nx">idKey</span><span class="p">],</span>
          <span class="na">label</span><span class="p">:</span> <span class="nx">row</span><span class="p">[</span><span class="nx">labelKey</span><span class="p">],</span>
          <span class="na">checked</span><span class="p">:</span> <span class="nx">row</span><span class="p">.</span><span class="nx">checked</span> <span class="o">||</span> <span class="kc">false</span><span class="p">,</span>
          <span class="nx">children</span>
        <span class="p">})</span>
      <span class="p">})</span>

    <span class="k">return</span> <span class="nx">currentNodes</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">nodes</span> <span class="o">=</span> <span class="nf">getNodes</span><span class="p">(</span><span class="nx">rows</span><span class="p">,</span> <span class="nx">rootId</span><span class="p">,</span> <span class="p">[])</span>
  <span class="kd">let</span> <span class="nx">root</span> <span class="o">=</span> <span class="nx">rows</span><span class="p">.</span><span class="nf">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">[</span><span class="nx">idKey</span><span class="p">]</span> <span class="o">==</span> <span class="nx">rootId</span><span class="p">)</span>
  <span class="nx">root</span> <span class="o">=</span> <span class="nx">root</span><span class="p">.</span><span class="nx">length</span> <span class="p">?</span> <span class="nx">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="kc">null</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nodes</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="p">...</span><span class="nx">root</span><span class="p">,</span>
        <span class="na">id</span><span class="p">:</span> <span class="nx">root</span><span class="p">[</span><span class="nx">idKey</span><span class="p">],</span>
        <span class="na">label</span><span class="p">:</span> <span class="nx">root</span><span class="p">[</span><span class="nx">labelKey</span><span class="p">],</span>
        <span class="na">checked</span><span class="p">:</span> <span class="nx">root</span><span class="p">.</span><span class="nx">checked</span> <span class="o">||</span> <span class="kc">false</span><span class="p">,</span>
        <span class="na">children</span><span class="p">:</span> <span class="nx">nodes</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">nodes</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Jessie Tang</name></author><category term="面试合集" /><category term="零散的知识点积累" /><category term="#算法，#数据转换，#tree形数据" /><summary type="html"><![CDATA[我们在实际开发需求的过程中，经常会遇到需要把list形式的数据，转成tree形的数据的场景。那么，是否可以写一个通用的方法来处理这种情形呢？ 直接上代码： const getTreeFromRows = ( rows, rootId, idKey = 'id', parentKey = 'parent', labelKey = 'name' ) =&gt; { function getNodes(rows, rootId, currentNodes) { rows .filter(item =&gt; item[parentKey] == rootId) .forEach(row =&gt; { let children = getNodes(rows, row[idKey], []) if (!children.length) children = null currentNodes.push({ ...row, id: row[idKey], label: row[labelKey], checked: row.checked || false, children }) }) return currentNodes } let nodes = getNodes(rows, rootId, []) let root = rows.filter(item =&gt; item[idKey] == rootId) root = root.length ? root[0] : null if (root) { nodes = [ { ...root, id: root[idKey], label: root[labelKey], checked: root.checked || false, children: nodes } ] } return nodes }]]></summary></entry><entry><title type="html">findIndex(numArr, sum)用时间复杂度是o(n)的算法来实现</title><link href="http://localhost:4000/blog/2022/04/30/findIndex(numArr,-sum)%E7%94%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AFo(n)%E7%9A%84%E7%AE%97%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0.html" rel="alternate" type="text/html" title="findIndex(numArr, sum)用时间复杂度是o(n)的算法来实现" /><published>2022-04-30T00:00:00+08:00</published><updated>2022-04-30T00:00:00+08:00</updated><id>http://localhost:4000/blog/2022/04/30/findIndex(numArr,%20sum)%E7%94%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AFo(n)%E7%9A%84%E7%AE%97%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0</id><content type="html" xml:base="http://localhost:4000/blog/2022/04/30/findIndex(numArr,-sum)%E7%94%A8%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AFo(n)%E7%9A%84%E7%AE%97%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0.html"><![CDATA[<h4 id="问题-实现一个findindex算法可以满足如下规律实现索引在数组里面对应的值加起来等于第二个参数sum时间复杂度为on">问题： 实现一个findIndex算法可以满足如下规律：实现索引在数组里面对应的值加起来等于第二个参数sum，时间复杂度为o(n)</h4>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">findIndex</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// [1, 2]</span>
<span class="nf">findIndex</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// [0, 3]</span>
<span class="nf">findIndex</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// [0,1] || [1,2] || [0,2]</span>
</code></pre></div></div>

<p>我刚开始用for循环来实现的：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">j</span><span class="o">=</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="nx">j</span><span class="o">&lt;</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">sum</span><span class="p">){</span>
            <span class="k">return</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>但是这样实现的时间复杂度为o(n^2)</p>

<p>实现为时间复杂度为o(n)的算法，分析如下：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    [5-1]: 3,
    [5-2]: 2,
    [5-3]: 1,
    [5-4]: 0,
    [5-5]: 4
}
</code></pre></div></div>
<p>这样只需要在外面循环一次，从一个对象里面取某个属性，时间复杂度是常数。</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">findIndex</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="nx">sum</span> <span class="o">-</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">[</span><span class="nx">obj</span><span class="p">[(</span><span class="nx">sum</span> <span class="o">-</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]))],</span> <span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">obj</span><span class="p">.</span><span class="nf">hasOwnProperty</span><span class="p">(</span><span class="nx">sum</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="nx">obj</span><span class="p">[</span><span class="nx">sum</span> <span class="o">-</span> <span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Jessie Tang</name></author><category term="面试合集" /><category term="#面试," /><category term="#算法" /><summary type="html"><![CDATA[问题： 实现一个findIndex算法可以满足如下规律：实现索引在数组里面对应的值加起来等于第二个参数sum，时间复杂度为o(n) findIndex([1,2,3,4,5], 5) // [1, 2] findIndex([1,2,5,4], 5) // [0, 3] findIndex([1,1,1], 2) // [0,1] || [1,2] || [0,2] 我刚开始用for循环来实现的： for(let i=0; i&lt;arr.length; i++){ for(let j=i+1; j&lt;arr.length){ if(arr[i] + arr[j] == sum){ return [i, j] } } } 但是这样实现的时间复杂度为o(n^2) 实现为时间复杂度为o(n)的算法，分析如下： { [5-1]: 3, [5-2]: 2, [5-3]: 1, [5-4]: 0, [5-5]: 4 } 这样只需要在外面循环一次，从一个对象里面取某个属性，时间复杂度是常数。 function findIndex(arr, sum) { var obj = {}; for (let i = 0; i &lt; arr.length; i++) { if (obj.hasOwnProperty(sum - (sum - arr[i]))) { return [obj[(sum - (sum - arr[i]))], i]; } if (!obj.hasOwnProperty(sum - arr[i])) { obj[sum - arr[i]] = i; } } }]]></summary></entry><entry><title type="html">算法判断字符串是否合法</title><link href="http://localhost:4000/blog/2022/04/29/%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95.html" rel="alternate" type="text/html" title="算法判断字符串是否合法" /><published>2022-04-29T00:00:00+08:00</published><updated>2022-04-29T00:00:00+08:00</updated><id>http://localhost:4000/blog/2022/04/29/%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95</id><content type="html" xml:base="http://localhost:4000/blog/2022/04/29/%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%90%88%E6%B3%95.html"><![CDATA[<h4 id="问题给定一个字符串判断它是否合法是否闭合正确例合法--abcde-等-不合法a-等">问题：给定一个字符串，判断它是否合法（是否闭合正确）。例：合法：[] 、{}, ()、{[()]}、(a{b[c]d}e) 等； 不合法：[{)]、({[a)}) 等。</h4>

<p>思考： 其实主要是看是否”对称”，但又不是类似“1221”或者“abccba”这种对称。所以相当于是有一个键值对的对应关系。如，”[“对应”]”等</p>

<ul>
  <li>实现方法1，存一个键值对：</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">isValid</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// '1t2e3s4t5'.replace(/[^tes]/g, '')  -&gt; 得到 test.  把不是t、e、s这三种字符的其他字符替换成空</span>

            <span class="c1">// https://blog.csdn.net/xuyangxinlei/article/details/81359366</span>
            <span class="c1">// 字符串：helloword123</span>
            <span class="c1">// /[^0-9]+/g 可以匹配非数字 得到helloword</span>
            <span class="c1">// /[^he]+/g 可以匹配非h非e的字符 得到lloword123</span>
            <span class="c1">// /[^hello]/g 非h非e非l非o，并不能理解为 非(hello)，所以匹配结果是 w 和 rd123。</span>
            <span class="c1">// 可我们就是想匹配非某个字符串呢？比如某一字符串若是含有hello则无匹配，若是不含hello则匹配，</span>
            <span class="c1">// 写成[^hello]是显然不行的，[^(hello)] 呢？其实不起作用。</span>
            <span class="c1">// 这时我们需要用到正则表达式的断言——(?!pattern) 零宽负向先行断言 或者 (?&lt;!pattern) 零宽负向后行断言 均可。</span>
            <span class="c1">// /^((?!hello).)+$/</span>
            <span class="c1">// 由于断言 (?!hello)是不占位的，后跟的 . 在原位置匹配任意字符，再用括号将其括起来，用+重复一次或多次，前后加上^和$，若是字符串中存在hello，则匹配到h字符之前的时候，断言(?!hello)匹配失败，正则匹配结果为false， 若是字符串中不存在hello，则匹配结果是整个字符串。</span>

            <span class="c1">// 注意区分，以什么什么开头，和， 非什么什么。  'test'.replace(/^te/g, '&amp;') -&gt; &amp;st</span>
            <span class="c1">// 把不是[、{、(、)、}、]这几种字符的全部替换成空  特殊符号，需要转义</span>
            <span class="nx">s</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">[^\[\{\(\)\}\]]</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">''</span><span class="p">)</span>

            <span class="c1">// &amp; 是按位与运算符 n&amp;1 ： 先把n 和 1分别转换为二进制，然后对比他们二进制每个位上的数，</span>
            <span class="c1">// 当双方位置上的数都为1时 结果为1 其它情况都为0，</span>
            <span class="c1">// 得到n与1按位与计算的二进制结果后再转为十进制与1做是否相等比较。</span>
            <span class="c1">// 3 ： 0011</span>
            <span class="c1">// 1 ： 0001</span>
            <span class="c1">// 3&amp;1 ： 0001  -&gt;  1</span>
            <span class="c1">// n&amp;1 只有两个结果 当n的最后一位数为1时(n为奇数) n&amp;1=1，其它情况 n&amp;1=0</span>
            <span class="k">if </span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 奇数肯定是false，直接返回节省时间   </span>

            <span class="kd">let</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// 栈，先进后出</span>
            <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">// 存一个键值对，同理也可以用map存，也可以不存，不存的话就会多几个if匹配语句        </span>
                <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">,</span>
                <span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">[</span><span class="dl">"</span><span class="p">,</span>
                <span class="dl">"</span><span class="s2">}</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">{</span><span class="dl">"</span>
            <span class="p">};</span>
            <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">[</span><span class="dl">'</span> <span class="o">||</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">{</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">//匹配左括号            </span>
                    <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>

                <span class="p">}</span> <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]])</span> <span class="p">{</span>
                    <span class="c1">//匹配右括号            </span>
                    <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">();</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="o">!</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<ul>
  <li>实现方法2：
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">isValid</span> <span class="o">=</span> <span class="nf">function </span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// '1t2e3s4t5'.replace(/[^tes]/g, '')  -&gt; 得到 test.  把不是t、e、s这三种字符的其他字符替换成空</span>
          <span class="c1">// 把不是[、{、(、)、}、]这几种字符的全部替换成空  特殊符号，需要转义</span>
          <span class="nx">s</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">[^\[\{\(\)\}\]]</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">''</span><span class="p">)</span>
          <span class="c1">// 如果是奇数，不可能匹配成功，直接返回false    </span>
          <span class="k">if </span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span>
          <span class="kd">let</span> <span class="nx">stack</span> <span class="o">=</span> <span class="p">[]</span>
          <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">(</span><span class="dl">'</span> <span class="o">||</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">{</span><span class="dl">'</span> <span class="o">||</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">[</span><span class="dl">'</span><span class="p">)</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
              <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">)</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">(</span><span class="dl">'</span><span class="p">)</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
              <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">}</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">{</span><span class="dl">'</span><span class="p">)</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
              <span class="k">else</span> <span class="k">if </span><span class="p">(</span><span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">]</span><span class="dl">'</span> <span class="o">&amp;&amp;</span> <span class="nx">stack</span><span class="p">[</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">[</span><span class="dl">'</span><span class="p">)</span> <span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
              <span class="k">else</span> <span class="k">return</span> <span class="kc">false</span>
          <span class="p">}</span>
          <span class="k">return</span> <span class="o">!</span><span class="nx">stack</span><span class="p">.</span><span class="nx">length</span>
<span class="p">};</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>Jessie Tang</name></author><category term="面试合集" /><category term="零散的知识点积累" /><category term="#算法" /><summary type="html"><![CDATA[问题：给定一个字符串，判断它是否合法（是否闭合正确）。例：合法：[] 、{}, ()、{[()]}、(a{b[c]d}e) 等； 不合法：[{)]、({[a)}) 等。 思考： 其实主要是看是否”对称”，但又不是类似“1221”或者“abccba”这种对称。所以相当于是有一个键值对的对应关系。如，”[“对应”]”等 实现方法1，存一个键值对： var isValid = function (s) { // '1t2e3s4t5'.replace(/[^tes]/g, '') -&gt; 得到 test. 把不是t、e、s这三种字符的其他字符替换成空 // https://blog.csdn.net/xuyangxinlei/article/details/81359366 // 字符串：helloword123 // /[^0-9]+/g 可以匹配非数字 得到helloword // /[^he]+/g 可以匹配非h非e的字符 得到lloword123 // /[^hello]/g 非h非e非l非o，并不能理解为 非(hello)，所以匹配结果是 w 和 rd123。 // 可我们就是想匹配非某个字符串呢？比如某一字符串若是含有hello则无匹配，若是不含hello则匹配， // 写成[^hello]是显然不行的，[^(hello)] 呢？其实不起作用。 // 这时我们需要用到正则表达式的断言——(?!pattern) 零宽负向先行断言 或者 (?&lt;!pattern) 零宽负向后行断言 均可。 // /^((?!hello).)+$/ // 由于断言 (?!hello)是不占位的，后跟的 . 在原位置匹配任意字符，再用括号将其括起来，用+重复一次或多次，前后加上^和$，若是字符串中存在hello，则匹配到h字符之前的时候，断言(?!hello)匹配失败，正则匹配结果为false， 若是字符串中不存在hello，则匹配结果是整个字符串。 // 注意区分，以什么什么开头，和， 非什么什么。 'test'.replace(/^te/g, '&amp;') -&gt; &amp;st // 把不是[、{、(、)、}、]这几种字符的全部替换成空 特殊符号，需要转义 s = str.replace(/[^\[\{\(\)\}\]]/g, '') // &amp; 是按位与运算符 n&amp;1 ： 先把n 和 1分别转换为二进制，然后对比他们二进制每个位上的数， // 当双方位置上的数都为1时 结果为1 其它情况都为0， // 得到n与1按位与计算的二进制结果后再转为十进制与1做是否相等比较。 // 3 ： 0011 // 1 ： 0001 // 3&amp;1 ： 0001 -&gt; 1 // n&amp;1 只有两个结果 当n的最后一位数为1时(n为奇数) n&amp;1=1，其它情况 n&amp;1=0 if (s.length &amp; 1) return false; // 奇数肯定是false，直接返回节省时间 let stack = []; // 栈，先进后出 let obj = { // 存一个键值对，同理也可以用map存，也可以不存，不存的话就会多几个if匹配语句 ")": "(", "]": "[", "}": "{" }; for (let i = 0; i &lt; s.length; i++) { if (s[i] === "(" || s[i] === '[' || s[i] === "{") { //匹配左括号 stack.push(s[i]); } else if (stack[stack.length - 1] === obj[s[i]]) { //匹配右括号 stack.pop(); } else { return false; } } return !stack.length; }; 实现方法2： var isValid = function (s) { // '1t2e3s4t5'.replace(/[^tes]/g, '') -&gt; 得到 test. 把不是t、e、s这三种字符的其他字符替换成空 // 把不是[、{、(、)、}、]这几种字符的全部替换成空 特殊符号，需要转义 s = str.replace(/[^\[\{\(\)\}\]]/g, '') // 如果是奇数，不可能匹配成功，直接返回false if (s.length &amp; 1) return false let stack = [] for (let i = 0; i &lt; s.length; i++) { if (s[i] === '(' || s[i] === '{' || s[i] === '[') stack.push(s[i]) else if (s[i] === ')' &amp;&amp; stack[stack.length - 1] === '(') stack.pop() else if (s[i] === '}' &amp;&amp; stack[stack.length - 1] === '{') stack.pop() else if (s[i] === ']' &amp;&amp; stack[stack.length - 1] === '[') stack.pop() else return false } return !stack.length };]]></summary></entry></feed>